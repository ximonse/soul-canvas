// src/components/canvas/SynapseLines.tsx
// Renderar synapse-linjer mellan kort baserat på semantiska kopplingar

import React, { useMemo } from 'react';
import { Line } from 'react-konva';
import type { MindNode, Synapse } from '../../types/types';

interface SynapseLinesProps {
  synapses: Synapse[];
  nodes: Map<string, MindNode>;
  visibilityThreshold: number;
  scale: number;
}

// Färgskala: röd (många kopplingar) → orange → gul → grön → blå → grå (få)
const getColorByConnections = (count: number, maxConnections: number) => {
  const ratio = count / maxConnections;
  if (ratio > 0.8) return '#ef4444'; // Röd
  if (ratio > 0.6) return '#f97316'; // Orange
  if (ratio > 0.4) return '#eab308'; // Gul
  if (ratio > 0.25) return '#22c55e'; // Grön
  if (ratio > 0.1) return '#3b82f6'; // Blå
  return '#9ca3af'; // Grå
};

const SynapseLinesComponent: React.FC<SynapseLinesProps> = ({
  synapses,
  nodes,
  visibilityThreshold,
  scale,
}) => {
  // Filtrera synapser baserat pǾ visibility threshold
  const visibleSynapses = useMemo(() => (
    synapses.filter(s => (s.similarity || 1) >= visibilityThreshold)
  ), [synapses, visibilityThreshold]);

  const { connectionCount, maxConnections } = useMemo(() => {
    const counts = new Map<string, number>();
    let max = 1;
    visibleSynapses.forEach(s => {
      const nextSource = (counts.get(s.sourceId) || 0) + 1;
      const nextTarget = (counts.get(s.targetId) || 0) + 1;
      counts.set(s.sourceId, nextSource);
      counts.set(s.targetId, nextTarget);
      max = Math.max(max, nextSource, nextTarget);
    });
    return { connectionCount: counts, maxConnections: max };
  }, [visibleSynapses]);

  return (
    <>
      {visibleSynapses.map((synapse) => {
        const sourceNode = nodes.get(synapse.sourceId);
        const targetNode = nodes.get(synapse.targetId);
        if (!sourceNode || !targetNode) return null;

        // Använd kortets centrum (uppskattad bredd/höjd)
        const sourceX = sourceNode.x + (sourceNode.width || 200) / 2;
        const sourceY = sourceNode.y + (sourceNode.height || 100) / 2;
        const targetX = targetNode.x + (targetNode.width || 200) / 2;
        const targetY = targetNode.y + (targetNode.height || 100) / 2;

        // Färg baserad på det kort som har flest kopplingar
        const sourceCount = connectionCount.get(synapse.sourceId) || 0;
        const targetCount = connectionCount.get(synapse.targetId) || 0;
        const maxCount = Math.max(sourceCount, targetCount);
        const lineColor = getColorByConnections(maxCount, maxConnections);

        // Auto-genererade länkar är mer transparenta
        const opacity = synapse.autoGenerated ? 0.4 : 0.7;
        const strokeWidth = synapse.autoGenerated ? 1.5 : 2;

        return (
          <Line
            key={synapse.id}
            points={[sourceX, sourceY, targetX, targetY]}
            stroke={lineColor}
            strokeWidth={strokeWidth / scale}
            opacity={opacity}
            lineCap="round"
            listening={false}
          />
        );
      })}
    </>
  );
};

export const SynapseLines = React.memo(SynapseLinesComponent);

// src/store/useBrainStore.ts
import { create } from 'zustand';
import type { AIProvider, MindNode, Synapse, Sequence } from '../types/types';
import { createSelectionSlice, type SelectionActions } from './slices/selectionSlice';
import { createHistorySlice, historyInitialState, type HistoryState, type HistoryActions } from './slices/historySlice';

// Core state interface
interface CoreState {
  nodes: Map<string, MindNode>;
  synapses: Synapse[];
  fileHandle: FileSystemDirectoryHandle | null;
  lastSaved: string | null;
  assets: Record<string, string>;

  // AI Keys & Settings
  geminiKey?: string;
  openaiKey?: string;
  claudeKey?: string;
  autoLinkThreshold?: number;
  enableAutoLink?: boolean;

  // UI State
  taggingNodes: Set<string>;  // Node IDs currently being auto-tagged
  showSynapseLines: boolean;  // Toggle för att visa/dölja linjer mellan kort
  graphGravity: number;       // Gravitations-styrka för graf-layout (0.1 - 3.0, default 1.0)
  synapseVisibilityThreshold: number;  // Visa bara kopplingar med similarity >= detta värde (0-1)

  // Sequences (D+klick kedjor)
  sequences: Sequence[];
  activeSequence: Sequence | null;  // Pågående kedja under D-hållning
}

// Core actions interface
interface CoreActions {
  setFileHandle: (handle: FileSystemDirectoryHandle | null) => void;
  setApiKey: (provider: AIProvider, key: string) => void;
  setAutoLinkThreshold: (threshold: number) => void;
  toggleAutoLink: () => void;
  toggleSynapseLines: () => void;
  setGraphGravity: (gravity: number) => void;
  setSynapseVisibilityThreshold: (threshold: number) => void;

  loadNodes: (nodes: MindNode[], synapses?: Synapse[]) => void;
  loadAssets: (assets: Record<string, string>) => void;
  createNodesMap: (nodesArray: MindNode[]) => Map<string, MindNode>;

  addNode: (content: string, x: number, y: number, type?: 'text'|'image'|'zotero') => void;
  addNodeWithId: (id: string, content: string, x: number, y: number, type?: 'text'|'image'|'zotero') => void;
  removeNode: (id: string) => void;
  updateNode: (id: string, updates: Partial<MindNode>) => void;
  addSynapse: (sourceId: string, targetId: string, metadata?: { autoGenerated?: boolean; similarity?: number }) => void;
  updateNodePosition: (id: string, x: number, y: number) => void;
  updateNodePositions: (positions: Map<string, { x: number; y: number }>) => void;

  // AI processing state
  setNodeTagging: (nodeId: string, isTagging: boolean) => void;

  // Sequence actions (D+klick kedjor)
  startSequence: (nodeId: string) => void;
  addToSequence: (nodeId: string) => void;
  finishSequence: () => void;
  cancelSequence: () => void;
  removeFromSequence: (nodeId: string) => void;
}

const PROVIDER_STORAGE_KEYS: Record<AIProvider, string> = {
  gemini: 'gemini_key',
  openai: 'openai_key',
  claude: 'claude_key',
};

const PROVIDER_STATE_KEYS: Record<AIProvider, 'geminiKey' | 'openaiKey' | 'claudeKey'> = {
  gemini: 'geminiKey',
  openai: 'openaiKey',
  claude: 'claudeKey',
};

const getInitialApiKey = (provider: AIProvider) =>
  localStorage.getItem(PROVIDER_STORAGE_KEYS[provider]) || '';

// Combined store type
type BrainStore = CoreState & HistoryState & CoreActions & SelectionActions & HistoryActions;

export const useBrainStore = create<BrainStore>()((set) => ({
  // Initial state
  nodes: new Map(),
  synapses: [],
  fileHandle: null,
  lastSaved: null,
  assets: {},
  taggingNodes: new Set(),
  showSynapseLines: false,
  graphGravity: 1.0,
  sequences: [],
  activeSequence: null,
  synapseVisibilityThreshold: 0,  // Default: visa alla kopplingar
  ...historyInitialState,

  // AI Keys & Settings
  geminiKey: getInitialApiKey('gemini'),
  openaiKey: getInitialApiKey('openai'),
  claudeKey: getInitialApiKey('claude'),
  autoLinkThreshold: 0.75,
  enableAutoLink: false,

  // Settings actions
  setFileHandle: (handle) => set({ fileHandle: handle }),

  setApiKey: (provider, key) => set(() => {
    const storageKey = PROVIDER_STORAGE_KEYS[provider];
    const stateKey = PROVIDER_STATE_KEYS[provider];

    localStorage.setItem(storageKey, key);
    return { [stateKey]: key } as Pick<CoreState, typeof stateKey>;
  }),

  setAutoLinkThreshold: (threshold) => set({ autoLinkThreshold: threshold }),
  toggleAutoLink: () => set((state) => ({ enableAutoLink: !state.enableAutoLink })),
  toggleSynapseLines: () => set((state) => ({ showSynapseLines: !state.showSynapseLines })),
  setGraphGravity: (gravity) => set({ graphGravity: Math.max(0.05, Math.min(5.0, gravity)) }),
  setSynapseVisibilityThreshold: (threshold) => set({ synapseVisibilityThreshold: Math.max(0, Math.min(1, threshold)) }),

  // Helper function
  createNodesMap: (nodesArray: MindNode[]) => {
    const nodesMap = new Map<string, MindNode>();
    nodesArray.forEach(node => nodesMap.set(node.id, node));
    return nodesMap;
  },

  // Data loading
  loadNodes: (nodesArray, synapses = []) => set((state) => ({
    nodes: state.createNodesMap(nodesArray),
    synapses
  })),
  loadAssets: (assets) => set({ assets }),

  // Node CRUD
  addNode: (content, x, y, type = 'text') => set((state) => {
    const newNode: MindNode = {
      id: crypto.randomUUID(),
      content,
      x, y, z: 0,
      tags: [],
      type,
      createdAt: new Date().toISOString(),
      selected: false
    };
    const newNodes = new Map(state.nodes);
    newNodes.set(newNode.id, newNode);
    return { nodes: newNodes };
  }),

  addNodeWithId: (id, content, x, y, type = 'text') => set((state) => {
    const newNode: MindNode = {
      id,
      content,
      x, y, z: 0,
      tags: [],
      type,
      createdAt: new Date().toISOString(),
      selected: false
    };
    const newNodes = new Map(state.nodes);
    newNodes.set(newNode.id, newNode);
    return { nodes: newNodes };
  }),

  removeNode: (id) => set((state) => {
    const newNodes = new Map(state.nodes);
    newNodes.delete(id);
    return {
      nodes: newNodes,
      synapses: state.synapses.filter(s => s.sourceId !== id && s.targetId !== id)
    };
  }),

  updateNode: (id, updates) => set((state) => {
    const existingNode = state.nodes.get(id);
    if (!existingNode) return {};
    const updatedNode = { ...existingNode, ...updates };
    const newNodes = new Map(state.nodes);
    newNodes.set(id, updatedNode);
    return { nodes: newNodes };
  }),

  addSynapse: (sourceId, targetId, metadata) => set((state) => {
    const exists = state.synapses.find(s =>
      (s.sourceId === sourceId && s.targetId === targetId) ||
      (s.sourceId === targetId && s.targetId === sourceId)
    );
    if (exists) return {};
    return {
      synapses: [...state.synapses, {
        id: crypto.randomUUID(),
        sourceId,
        targetId,
        strength: 1,
        ...metadata
      }]
    };
  }),

  updateNodePosition: (id, x, y) => set((state) => {
    const existingNode = state.nodes.get(id);
    if (!existingNode) return {};
    const updatedNode = { ...existingNode, x, y };
    const newNodes = new Map(state.nodes);
    newNodes.set(id, updatedNode);
    return { nodes: newNodes };
  }),

  updateNodePositions: (positions) => set((state) => {
    if (!positions || positions.size === 0) return {};

    let changed = false;
    const newNodes = new Map(state.nodes);

    positions.forEach((pos, id) => {
      const existingNode = newNodes.get(id);
      if (existingNode) {
        const dx = Math.abs((existingNode.x || 0) - pos.x);
        const dy = Math.abs((existingNode.y || 0) - pos.y);

        // Use 0.5px threshold to allow arrangement functions to make subtle changes
        if (dx > 0.5 || dy > 0.5) {
          changed = true;
          newNodes.set(id, { ...existingNode, x: pos.x, y: pos.y });
        }
      }
    });

    if (!changed) return {};
    return { nodes: newNodes };
  }),

  // AI processing state
  setNodeTagging: (nodeId, isTagging) => set((state) => {
    const newSet = new Set(state.taggingNodes);
    if (isTagging) {
      newSet.add(nodeId);
    } else {
      newSet.delete(nodeId);
    }
    return { taggingNodes: newSet };
  }),

  // Sequence actions (D+klick kedjor)
  startSequence: (nodeId) => set(() => ({
    activeSequence: {
      id: crypto.randomUUID(),
      nodeIds: [nodeId],
      createdAt: new Date().toISOString(),
    }
  })),

  addToSequence: (nodeId) => set((state) => {
    if (!state.activeSequence) return {};
    // Ignorera om kortet redan finns i kedjan
    if (state.activeSequence.nodeIds.includes(nodeId)) return {};
    return {
      activeSequence: {
        ...state.activeSequence,
        nodeIds: [...state.activeSequence.nodeIds, nodeId],
      }
    };
  }),

  finishSequence: () => set((state) => {
    if (!state.activeSequence) return {};
    // Spara bara om det finns minst 2 kort
    if (state.activeSequence.nodeIds.length < 2) {
      return { activeSequence: null };
    }
    return {
      sequences: [...state.sequences, state.activeSequence],
      activeSequence: null,
    };
  }),

  cancelSequence: () => set(() => ({
    activeSequence: null,
  })),

  removeFromSequence: (nodeId) => set((state) => {
    // Hitta sekvensen som innehåller nodeId
    const sequenceIndex = state.sequences.findIndex(s => s.nodeIds.includes(nodeId));
    if (sequenceIndex === -1) return {};

    const sequence = state.sequences[sequenceIndex];
    const newNodeIds = sequence.nodeIds.filter(id => id !== nodeId);

    // Om färre än 2 kort kvar, ta bort hela sekvensen
    if (newNodeIds.length < 2) {
      return {
        sequences: state.sequences.filter((_, i) => i !== sequenceIndex),
      };
    }

    // Annars uppdatera sekvensen (sys ihop)
    const updatedSequence = { ...sequence, nodeIds: newNodeIds };
    const newSequences = [...state.sequences];
    newSequences[sequenceIndex] = updatedSequence;
    return { sequences: newSequences };
  }),

  // Selection slice
  ...createSelectionSlice(set as any),

  // History slice
  ...createHistorySlice(set as any),
}));

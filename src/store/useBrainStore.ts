// src/store/useBrainStore.ts
import { create } from 'zustand';
import type { AIProvider, MindNode, Synapse, Sequence, Conversation, ConversationMessage, Session } from '../types/types';
import { createSelectionSlice, type SelectionActions } from './slices/selectionSlice';
import { createHistorySlice, historyInitialState, type HistoryState, type HistoryActions } from './slices/historySlice';
import { GRAVITY } from '../utils/constants';

// Core state interface
interface CoreState {
  nodes: Map<string, MindNode>;
  synapses: Synapse[];
  fileHandle: FileSystemDirectoryHandle | null;
  lastSaved: string | null;
  assets: Record<string, string>;

  // AI Keys & Settings
  geminiKey?: string;
  openaiKey?: string;
  claudeKey?: string;
  autoLinkThreshold?: number;
  enableAutoLink?: boolean;

  // UI State
  taggingNodes: Set<string>;  // Node IDs currently being auto-tagged
  showSynapseLines: boolean;  // Toggle för att visa/dölja linjer mellan kort
  graphGravity: number;       // Gravitations-styrka för graf-layout (0.1 - 3.0, default 1.0)
  synapseVisibilityThreshold: number;  // Visa bara kopplingar med similarity >= detta värde (0-1)
  includeTags: string[];   // Taggar att inkludera (visa bara kort med dessa)
  excludeTags: string[];   // Taggar att exkludera (dölj kort med dessa)

  // Sequences (D+klick kedjor)
  sequences: Sequence[];
  activeSequence: Sequence | null;  // Pågående kedja under D-hållning

  // Conversations (AI-chattar med minne)
  conversations: Conversation[];
  activeConversationId: string | null;

  // Sessions (arbetsytor/projekt)
  sessions: Session[];
  activeSessionId: string | null;  // null = "all-inclusive" (visa alla kort)
}

// Core actions interface
interface CoreActions {
  setFileHandle: (handle: FileSystemDirectoryHandle | null) => void;
  setApiKey: (provider: AIProvider, key: string) => void;
  setAutoLinkThreshold: (threshold: number) => void;
  toggleAutoLink: () => void;
  toggleSynapseLines: () => void;
  setGraphGravity: (gravity: number) => void;
  setSynapseVisibilityThreshold: (threshold: number) => void;
  toggleTagFilter: (tag: string) => void;  // Växla: neutral → include → exclude → neutral
  clearTagFilter: () => void;

  loadNodes: (nodes: MindNode[], synapses?: Synapse[]) => void;
  loadAssets: (assets: Record<string, string>) => void;
  createNodesMap: (nodesArray: MindNode[]) => Map<string, MindNode>;

  addNode: (content: string, x: number, y: number, type?: 'text'|'image'|'zotero') => void;
  addNodeWithId: (id: string, content: string, x: number, y: number, type?: 'text'|'image'|'zotero') => void;
  removeNode: (id: string) => void;
  updateNode: (id: string, updates: Partial<MindNode>) => void;
  addSynapse: (sourceId: string, targetId: string, metadata?: { autoGenerated?: boolean; similarity?: number }) => void;
  updateNodePosition: (id: string, x: number, y: number) => void;
  updateNodePositions: (positions: Map<string, { x: number; y: number }>) => void;
  setPendingSave: (pending: boolean) => void;

  // AI processing state
  setNodeTagging: (nodeId: string, isTagging: boolean) => void;

  // Sequence actions (D+klick kedjor)
  startSequence: (nodeId: string) => void;
  addToSequence: (nodeId: string) => void;
  finishSequence: () => void;
  cancelSequence: () => void;
  removeFromSequence: (nodeId: string) => void;

  // Conversation actions (AI-chattar med minne)
  loadConversations: (conversations: Conversation[]) => void;
  createConversation: (provider: 'claude' | 'openai' | 'gemini', contextNodeIds?: string[]) => string;
  setActiveConversation: (id: string | null) => void;
  addMessageToConversation: (conversationId: string, message: Omit<ConversationMessage, 'timestamp'>) => void;
  updateConversation: (id: string, updates: Partial<Conversation>) => void;
  archiveConversation: (id: string) => void;

  // Session actions
  loadSessions: (sessions: Session[]) => void;
  createSession: (name: string) => string;
  deleteSession: (id: string) => void;
  renameSession: (id: string, name: string) => void;
  switchSession: (id: string | null) => void;
  addCardsToSession: (sessionId: string, cardIds: string[]) => void;
  removeCardsFromSession: (sessionId: string, cardIds: string[]) => void;
  saveSessionViewState: (sessionId: string, viewState: { x: number; y: number; zoom: number }) => void;
}

const PROVIDER_STORAGE_KEYS: Record<AIProvider, string> = {
  gemini: 'gemini_key',
  openai: 'openai_key',
  claude: 'claude_key',
};

const PROVIDER_STATE_KEYS: Record<AIProvider, 'geminiKey' | 'openaiKey' | 'claudeKey'> = {
  gemini: 'geminiKey',
  openai: 'openaiKey',
  claude: 'claudeKey',
};

const getInitialApiKey = (provider: AIProvider) =>
  localStorage.getItem(PROVIDER_STORAGE_KEYS[provider]) || '';

// Combined store type
type BrainStore = CoreState & HistoryState & CoreActions & SelectionActions & HistoryActions;

export const useBrainStore = create<BrainStore>()((set) => ({
  // Initial state
  nodes: new Map(),
  synapses: [],
  fileHandle: null,
  lastSaved: null,
  assets: {},
  taggingNodes: new Set(),
  showSynapseLines: false,
  graphGravity: 1.0,
  sequences: [],
  activeSequence: null,
  synapseVisibilityThreshold: 0,  // Default: visa alla kopplingar
  conversations: [],
  activeConversationId: null,
  sessions: [],
  activeSessionId: null,
  includeTags: [],
  excludeTags: [],
  ...historyInitialState,

  // AI Keys & Settings
  geminiKey: getInitialApiKey('gemini'),
  openaiKey: getInitialApiKey('openai'),
  claudeKey: getInitialApiKey('claude'),
  autoLinkThreshold: 0.75,
  enableAutoLink: false,

  // Settings actions
  setFileHandle: (handle) => set({ fileHandle: handle }),

  setApiKey: (provider, key) => set(() => {
    const storageKey = PROVIDER_STORAGE_KEYS[provider];
    const stateKey = PROVIDER_STATE_KEYS[provider];

    localStorage.setItem(storageKey, key);
    return { [stateKey]: key } as Pick<CoreState, typeof stateKey>;
  }),

  setAutoLinkThreshold: (threshold) => set({ autoLinkThreshold: threshold }),
  toggleAutoLink: () => set((state) => ({ enableAutoLink: !state.enableAutoLink })),
  toggleSynapseLines: () => set((state) => ({ showSynapseLines: !state.showSynapseLines })),
  setGraphGravity: (gravity) => set({ graphGravity: Math.max(GRAVITY.MIN, Math.min(GRAVITY.MAX, gravity)) }),
  setSynapseVisibilityThreshold: (threshold) => set({ synapseVisibilityThreshold: Math.max(0, Math.min(1, threshold)) }),

  // Växla tagg-filter: neutral → include → exclude → neutral
  toggleTagFilter: (tag) => set((state) => {
    const clean = tag.trim();
    if (!clean) return {};

    const inInclude = state.includeTags.includes(clean);
    const inExclude = state.excludeTags.includes(clean);

    if (!inInclude && !inExclude) {
      // neutral → include
      return { includeTags: [...state.includeTags, clean] };
    } else if (inInclude) {
      // include → exclude
      return {
        includeTags: state.includeTags.filter(t => t !== clean),
        excludeTags: [...state.excludeTags, clean]
      };
    } else {
      // exclude → neutral
      return { excludeTags: state.excludeTags.filter(t => t !== clean) };
    }
  }),

  clearTagFilter: () => set({ includeTags: [], excludeTags: [] }),

  // Helper function
  createNodesMap: (nodesArray: MindNode[]) => {
    const nodesMap = new Map<string, MindNode>();
    nodesArray.forEach(node => nodesMap.set(node.id, node));
    return nodesMap;
  },

  // Data loading
  loadNodes: (nodesArray, synapses = []) => set((state) => ({
    nodes: state.createNodesMap(nodesArray),
    synapses,
    pendingSave: false,
  })),
  loadAssets: (assets) => set({ assets }),

  // Node CRUD
  addNode: (content, x, y, type = 'text') => set((state) => {
    const newNode: MindNode = {
      id: crypto.randomUUID(),
      content,
      x, y, z: 0,
      tags: [],
      type,
      createdAt: new Date().toISOString(),
      selected: false
    };
    const newNodes = new Map(state.nodes);
    newNodes.set(newNode.id, newNode);
    // Auto-lägg till i aktiv session
    let newSessions = state.sessions;
    if (state.activeSessionId) {
      newSessions = state.sessions.map(s =>
        s.id === state.activeSessionId
          ? { ...s, cardIds: [...s.cardIds, newNode.id] }
          : s
      );
    }
    return { nodes: newNodes, sessions: newSessions, pendingSave: true };
  }),

  addNodeWithId: (id, content, x, y, type = 'text') => set((state) => {
    const newNode: MindNode = {
      id,
      content,
      x, y, z: 0,
      tags: [],
      type,
      createdAt: new Date().toISOString(),
      selected: false
    };
    const newNodes = new Map(state.nodes);
    newNodes.set(newNode.id, newNode);
    // Auto-lägg till i aktiv session
    let newSessions = state.sessions;
    if (state.activeSessionId) {
      newSessions = state.sessions.map(s =>
        s.id === state.activeSessionId
          ? { ...s, cardIds: [...s.cardIds, id] }
          : s
      );
    }
    return { nodes: newNodes, sessions: newSessions, pendingSave: true };
  }),

  removeNode: (id) => set((state) => {
    const newNodes = new Map(state.nodes);
    newNodes.delete(id);
    return {
      nodes: newNodes,
      synapses: state.synapses.filter(s => s.sourceId !== id && s.targetId !== id),
      pendingSave: true
    };
  }),

  updateNode: (id, updates) => set((state) => {
    const existingNode = state.nodes.get(id);
    if (!existingNode) return {};
    const updatedNode = { ...existingNode, ...updates };
    const newNodes = new Map(state.nodes);
    newNodes.set(id, updatedNode);
    return { nodes: newNodes, pendingSave: true };
  }),

  addSynapse: (sourceId, targetId, metadata) => set((state) => {
    const exists = state.synapses.find(s =>
      (s.sourceId === sourceId && s.targetId === targetId) ||
      (s.sourceId === targetId && s.targetId === sourceId)
    );
    if (exists) return {};
    return {
      synapses: [...state.synapses, {
        id: crypto.randomUUID(),
        sourceId,
        targetId,
        strength: 1,
        ...metadata
      }],
      pendingSave: true
    };
  }),

  updateNodePosition: (id, x, y) => set((state) => {
    const existingNode = state.nodes.get(id);
    if (!existingNode) return {};
    const updatedNode = { ...existingNode, x, y };
    const newNodes = new Map(state.nodes);
    newNodes.set(id, updatedNode);
    return { nodes: newNodes, pendingSave: true };
  }),

  updateNodePositions: (positions) => set((state) => {
    if (!positions || positions.size === 0) return {};

    let changed = false;
    const newNodes = new Map(state.nodes);

    positions.forEach((pos, id) => {
      const existingNode = newNodes.get(id);
      if (existingNode) {
        const dx = Math.abs((existingNode.x || 0) - pos.x);
        const dy = Math.abs((existingNode.y || 0) - pos.y);

        // Use 0.5px threshold to allow arrangement functions to make subtle changes
        if (dx > 0.5 || dy > 0.5) {
          changed = true;
          newNodes.set(id, { ...existingNode, x: pos.x, y: pos.y });
        }
      }
    });

    if (!changed) return {};
    return { nodes: newNodes, pendingSave: true };
  }),

  setPendingSave: (pending) => set({ pendingSave: pending }),

  // AI processing state
  setNodeTagging: (nodeId, isTagging) => set((state) => {
    const newSet = new Set(state.taggingNodes);
    if (isTagging) {
      newSet.add(nodeId);
    } else {
      newSet.delete(nodeId);
    }
    return { taggingNodes: newSet };
  }),

  // Sequence actions (D+klick kedjor)
  startSequence: (nodeId) => set(() => ({
    activeSequence: {
      id: crypto.randomUUID(),
      nodeIds: [nodeId],
      createdAt: new Date().toISOString(),
    }
  })),

  addToSequence: (nodeId) => set((state) => {
    if (!state.activeSequence) return {};
    // Ignorera om kortet redan finns i kedjan
    if (state.activeSequence.nodeIds.includes(nodeId)) return {};
    return {
      activeSequence: {
        ...state.activeSequence,
        nodeIds: [...state.activeSequence.nodeIds, nodeId],
      }
    };
  }),

  finishSequence: () => set((state) => {
    if (!state.activeSequence) return {};
    // Spara bara om det finns minst 2 kort
    if (state.activeSequence.nodeIds.length < 2) {
      return { activeSequence: null };
    }
    return {
      sequences: [...state.sequences, state.activeSequence],
      activeSequence: null,
    };
  }),

  cancelSequence: () => set(() => ({
    activeSequence: null,
  })),

  removeFromSequence: (nodeId) => set((state) => {
    // Hitta sekvensen som innehåller nodeId
    const sequenceIndex = state.sequences.findIndex(s => s.nodeIds.includes(nodeId));
    if (sequenceIndex === -1) return {};

    const sequence = state.sequences[sequenceIndex];
    const newNodeIds = sequence.nodeIds.filter(id => id !== nodeId);

    // Om färre än 2 kort kvar, ta bort hela sekvensen
    if (newNodeIds.length < 2) {
      return {
        sequences: state.sequences.filter((_, i) => i !== sequenceIndex),
      };
    }

    // Annars uppdatera sekvensen (sys ihop)
    const updatedSequence = { ...sequence, nodeIds: newNodeIds };
    const newSequences = [...state.sequences];
    newSequences[sequenceIndex] = updatedSequence;
    return { sequences: newSequences };
  }),

  // Conversation actions (AI-chattar med minne)
  loadConversations: (conversations) => set({ conversations }),

  createConversation: (provider, contextNodeIds = []) => {
    const id = crypto.randomUUID();
    const now = new Date().toISOString();
    const newConversation: Conversation = {
      id,
      title: 'Nytt samtal',
      createdAt: now,
      updatedAt: now,
      messages: [],
      contextNodeIds,
      provider,
    };
    useBrainStore.setState((state) => ({
      conversations: [newConversation, ...state.conversations],
      activeConversationId: id,
    }));
    return id;
  },

  setActiveConversation: (id) => set({ activeConversationId: id }),

  addMessageToConversation: (conversationId, message) => set((state) => {
    const convIndex = state.conversations.findIndex(c => c.id === conversationId);
    if (convIndex === -1) return {};

    const conv = state.conversations[convIndex];
    const newMessage: ConversationMessage = {
      ...message,
      timestamp: new Date().toISOString(),
    };

    const updatedConv: Conversation = {
      ...conv,
      messages: [...conv.messages, newMessage],
      updatedAt: new Date().toISOString(),
      // Lägg till nya kort till kontexten om de finns
      contextNodeIds: message.addedNodeIds
        ? [...new Set([...conv.contextNodeIds, ...message.addedNodeIds])]
        : conv.contextNodeIds,
    };

    const newConversations = [...state.conversations];
    newConversations[convIndex] = updatedConv;
    return { conversations: newConversations };
  }),

  updateConversation: (id, updates) => set((state) => {
    const convIndex = state.conversations.findIndex(c => c.id === id);
    if (convIndex === -1) return {};

    const updatedConv: Conversation = {
      ...state.conversations[convIndex],
      ...updates,
      updatedAt: new Date().toISOString(),
    };

    const newConversations = [...state.conversations];
    newConversations[convIndex] = updatedConv;
    return { conversations: newConversations };
  }),

  archiveConversation: (id) => set((state) => {
    const convIndex = state.conversations.findIndex(c => c.id === id);
    if (convIndex === -1) return {};

    const updatedConv: Conversation = {
      ...state.conversations[convIndex],
      isArchived: true,
      updatedAt: new Date().toISOString(),
    };

    const newConversations = [...state.conversations];
    newConversations[convIndex] = updatedConv;
    return { conversations: newConversations };
  }),

  // Session actions
  loadSessions: (sessions) => set({ sessions }),

  createSession: (name) => {
    const id = crypto.randomUUID();
    const now = Date.now();
    const newSession: Session = {
      id,
      name,
      cardIds: [],
      viewState: { x: 0, y: 0, zoom: 1 },
      createdAt: now,
      lastOpened: now,
    };
    useBrainStore.setState((state) => ({
      sessions: [...state.sessions, newSession],
      activeSessionId: id,
    }));
    return id;
  },

  deleteSession: (id) => set((state) => ({
    sessions: state.sessions.filter(s => s.id !== id),
    activeSessionId: state.activeSessionId === id ? null : state.activeSessionId,
  })),

  renameSession: (id, name) => set((state) => ({
    sessions: state.sessions.map(s => s.id === id ? { ...s, name } : s),
  })),

  switchSession: (id) => set((state) => {
    // Spara nuvarande vy-state innan byte (om vi har en aktiv session)
    const currentSession = state.sessions.find(s => s.id === state.activeSessionId);
    if (currentSession) {
      // View state sparas separat via saveSessionViewState
    }
    return {
      activeSessionId: id,
      sessions: state.sessions.map(s =>
        s.id === id ? { ...s, lastOpened: Date.now() } : s
      ),
    };
  }),

  addCardsToSession: (sessionId, cardIds) => set((state) => ({
    sessions: state.sessions.map(s => {
      if (s.id !== sessionId) return s;
      const newCardIds = [...new Set([...s.cardIds, ...cardIds])];
      return { ...s, cardIds: newCardIds };
    }),
  })),

  removeCardsFromSession: (sessionId, cardIds) => set((state) => ({
    sessions: state.sessions.map(s => {
      if (s.id !== sessionId) return s;
      const cardIdSet = new Set(cardIds);
      return { ...s, cardIds: s.cardIds.filter(id => !cardIdSet.has(id)) };
    }),
  })),

  saveSessionViewState: (sessionId, viewState) => set((state) => ({
    sessions: state.sessions.map(s =>
      s.id === sessionId ? { ...s, viewState } : s
    ),
  })),

  // Selection slice
  ...createSelectionSlice(set as any),

  // History slice
  ...createHistorySlice(set as any),
}));

// src/store/useBrainStore.ts
import { create } from 'zustand';
import type { AIProvider, MindNode, Synapse, Sequence, Conversation, ConversationMessage, Session, ViewMode, SortOption } from '../types/types';
import { createSelectionSlice, type SelectionActions, type SelectionState } from './slices/selectionSlice';
import { createHistorySlice, historyInitialState, type HistoryState, type HistoryActions } from './slices/historySlice';
import { createTrailSlice, initialTrailState, type TrailState, type TrailActions } from './slices/trailSlice';
import { createNotificationSlice, type NotificationState, type NotificationActions } from './slices/notificationSlice';
import { GRAVITY } from '../utils/constants';
import { GEMINI_OCR_MODELS } from '../utils/gemini';

// Core state interface
interface CoreState {
  nodes: Map<string, MindNode>;
  synapses: Synapse[];
  fileHandle: FileSystemDirectoryHandle | null;
  lastSaved: string | null;
  assets: Record<string, string>;

  // AI Keys & Settings
  geminiKey?: string;
  geminiOcrModel?: string;
  openaiKey?: string;
  claudeKey?: string;
  autoLinkThreshold?: number;
  enableAutoLink?: boolean;

  // UI State
  taggingNodes: Set<string>;  // Node IDs currently being auto-tagged
  aiProcessingNodes: Map<string, AIProvider>; // Node IDs currently being processed by AI
  selectedNodeIds: Set<string>; // Selected node IDs (selection is not stored on nodes)
  showSynapseLines: boolean;  // Toggle för att visa/dölja linjer mellan kort
  graphGravity: number;       // Gravitations-styrka för graf-layout (0.1 - 3.0, default 1.0)
  synapseVisibilityThreshold: number;  // Visa bara kopplingar med similarity >= detta värde (0-1)
  includeTags: string[];   // Taggar att inkludera (visa bara kort med dessa)
  excludeTags: string[];   // Taggar att exkludera (dölj kort med dessa)

  // Sequences (D+klick kedjor)
  sequences: Sequence[];
  activeSequence: Sequence | null;  // Pågående kedja under D-hållning

  // Conversations (AI-chattar med minne)
  conversations: Conversation[];
  activeConversationId: string | null;

  // Sessions (arbetsytor/projekt)
  sessions: Session[];
  activeSessionId: string | null;  // null = "all-inclusive" (visa alla kort)

  // View mode (canvas vs column)
  viewMode: ViewMode;
  columnSort: SortOption;
  columnShowComments: boolean;
  columnShowTags: boolean;
  columnShowMeta: boolean;
  columnShowCaptions: boolean;
  columnCount: number;
  columnShowOnlySelected: boolean;
  canvasWeekView: boolean;
  canvasEternalView: boolean;
}

// Core actions interface
interface CoreActions {
  setFileHandle: (handle: FileSystemDirectoryHandle | null) => void;
  setApiKey: (provider: AIProvider, key: string) => void;
  setGeminiOcrModel: (model: string) => void;
  setAutoLinkThreshold: (threshold: number) => void;
  toggleAutoLink: () => void;
  toggleSynapseLines: () => void;
  setGraphGravity: (gravity: number) => void;
  setSynapseVisibilityThreshold: (threshold: number) => void;
  toggleTagFilter: (tag: string) => void;  // Växla: neutral → include → exclude → neutral
  clearTagFilter: () => void;

  loadNodes: (nodes: MindNode[], synapses?: Synapse[]) => void;
  loadAssets: (assets: Record<string, string>) => void;
  createNodesMap: (nodesArray: MindNode[]) => Map<string, MindNode>;

  addNode: (content: string, x: number, y: number, type?: 'text' | 'image' | 'zotero') => void;
  addNodeWithId: (id: string, content: string, x: number, y: number, type?: 'text' | 'image' | 'zotero') => void;
  removeNode: (id: string) => void;
  deleteNodesPermanently: (ids: string[]) => void;
  updateNode: (id: string, updates: Partial<MindNode>) => void;
  updateNodesBulk: (updates: Array<{ id: string; updates: Partial<MindNode> }>) => void;
  addSynapse: (sourceId: string, targetId: string, metadata?: { autoGenerated?: boolean; similarity?: number }) => void;
  updateNodePosition: (id: string, x: number, y: number) => void;
  updateNodePositions: (positions: Map<string, { x: number; y: number }>) => void;
  setPendingSave: (pending: boolean) => void;

  // AI processing state
  setNodeTagging: (nodeId: string, isTagging: boolean) => void;
  setNodeAIProcessing: (nodeId: string, provider: AIProvider | null) => void;

  // Flip image cards
  flipAllImageCardsToText: () => void;  // O+O: visa text på alla bildkort
  flipAllImageCardsToImage: () => void; // O: visa bilder på alla bildkort

  // Sequence actions (D+klick kedjor)
  startSequence: (nodeId: string) => void;
  addToSequence: (nodeId: string) => void;
  finishSequence: () => void;
  cancelSequence: () => void;
  removeFromSequence: (nodeId: string) => void;
  switchSession: (id: string | null) => void;
  createSession: (name: string) => string;
  deleteSession: (id: string) => void;
  renameSession: (id: string, name: string) => void;
  loadSessions: (sessions: Session[]) => void;
  addCardsToSession: (sessionId: string, cardIds: string[]) => void;
  removeCardsFromSession: (sessionId: string, cardIds: string[]) => void;
  saveSessionViewState: (sessionId: string, viewState: { x: number; y: number; zoom: number }) => void;

  // Conversation actions
  loadConversations: (conversations: Conversation[]) => void;
  createConversation: (provider: AIProvider, contextNodeIds?: string[]) => string;
  setActiveConversation: (id: string | null) => void;
  addMessageToConversation: (conversationId: string, message: Omit<ConversationMessage, 'timestamp'>) => void;
  updateConversation: (id: string, updates: Partial<Conversation>) => void;
  archiveConversation: (id: string) => void;

  // View mode actions
  setViewMode: (mode: ViewMode) => void;
  toggleViewMode: () => void;
  setColumnSort: (sort: SortOption) => void;
  setColumnCount: (count: number) => void;
  setColumnShowOnlySelected: (enabled: boolean) => void;
  setCanvasWeekView: (enabled: boolean) => void;
  setCanvasEternalView: (enabled: boolean) => void;
  toggleColumnShowComments: () => void;
  toggleColumnShowTags: () => void;
  toggleColumnShowMeta: () => void;
  toggleColumnShowCaptions: () => void;

  // Migration helpers
  migrateLinksFromCommentToLink: () => number;
}

const shouldTouchUpdatedAt = (updates: Partial<MindNode>): boolean => (
  'title' in updates ||
  'content' in updates ||
  'caption' in updates ||
  'comment' in updates ||
  'link' in updates
);

const PROVIDER_STORAGE_KEYS: Record<AIProvider, string> = {
  gemini: 'gemini_key',
  openai: 'openai_key',
  claude: 'claude_key',
};

const PROVIDER_STATE_KEYS: Record<AIProvider, 'geminiKey' | 'openaiKey' | 'claudeKey'> = {
  gemini: 'geminiKey',
  openai: 'openaiKey',
  claude: 'claudeKey',
};

const getInitialApiKey = (provider: AIProvider) =>
  localStorage.getItem(PROVIDER_STORAGE_KEYS[provider]) || '';

const GEMINI_OCR_MODEL_STORAGE_KEY = 'gemini_ocr_model';

const getInitialGeminiOcrModel = () => {
  const saved = localStorage.getItem(GEMINI_OCR_MODEL_STORAGE_KEY);
  if (saved && GEMINI_OCR_MODELS.includes(saved)) {
    return saved;
  }
  return GEMINI_OCR_MODELS[0];
};

// Combined store type
type BrainStore = CoreState & HistoryState & TrailState & SelectionState & NotificationState & CoreActions & SelectionActions & HistoryActions & TrailActions & NotificationActions;

export const useBrainStore = create<BrainStore>()((set, get, api) => ({
  // Initial state
  nodes: new Map(),
  synapses: [],
  fileHandle: null,
  lastSaved: null,
  assets: {},
  taggingNodes: new Set(),
  aiProcessingNodes: new Map(),
  selectedNodeIds: new Set(),
  showSynapseLines: false,
  graphGravity: 1.0,
  sequences: [],
  activeSequence: null,
  synapseVisibilityThreshold: 0,  // Default: visa alla kopplingar
  conversations: [],
  activeConversationId: null,
  sessions: [],
  activeSessionId: null,
  includeTags: [],
  excludeTags: [],
  viewMode: 'canvas',
  columnSort: 'newest',
  columnShowComments: false,
  columnShowTags: true,
  columnShowMeta: true,
  columnShowCaptions: true,
  columnCount: 1,
  columnShowOnlySelected: false,
  canvasWeekView: false,
  canvasEternalView: false,
  ...historyInitialState,
  ...initialTrailState,

  // AI Keys & Settings
  geminiKey: getInitialApiKey('gemini'),
  geminiOcrModel: getInitialGeminiOcrModel(),
  openaiKey: getInitialApiKey('openai'),
  claudeKey: getInitialApiKey('claude'),
  autoLinkThreshold: 0.75,
  enableAutoLink: false,

  // Settings actions
  setFileHandle: (handle) => set({ fileHandle: handle }),

  setApiKey: (provider, key) => set(() => {
    const storageKey = PROVIDER_STORAGE_KEYS[provider];
    const stateKey = PROVIDER_STATE_KEYS[provider];
    const trimmedKey = key.trim();

    localStorage.setItem(storageKey, trimmedKey);
    return { [stateKey]: trimmedKey } as Pick<CoreState, typeof stateKey>;
  }),

  setGeminiOcrModel: (model) => set(() => {
    const safeModel = GEMINI_OCR_MODELS.includes(model) ? model : GEMINI_OCR_MODELS[0];
    localStorage.setItem(GEMINI_OCR_MODEL_STORAGE_KEY, safeModel);
    return { geminiOcrModel: safeModel };
  }),

  setAutoLinkThreshold: (threshold) => set({ autoLinkThreshold: threshold }),
  toggleAutoLink: () => set((state) => ({ enableAutoLink: !state.enableAutoLink })),
  toggleSynapseLines: () => set((state) => ({ showSynapseLines: !state.showSynapseLines })),
  setGraphGravity: (gravity) => set({ graphGravity: Math.max(GRAVITY.MIN, Math.min(GRAVITY.MAX, gravity)) }),
  setSynapseVisibilityThreshold: (threshold) => set({ synapseVisibilityThreshold: Math.max(0, Math.min(1, threshold)) }),

  // Växla tagg-filter: neutral → include → exclude → neutral
  toggleTagFilter: (tag) => set((state) => {
    const clean = tag.trim();
    if (!clean) return {};

    const inInclude = state.includeTags.includes(clean);
    const inExclude = state.excludeTags.includes(clean);

    if (!inInclude && !inExclude) {
      // neutral → include
      return { includeTags: [...state.includeTags, clean] };
    } else if (inInclude) {
      // include → exclude
      return {
        includeTags: state.includeTags.filter(t => t !== clean),
        excludeTags: [...state.excludeTags, clean]
      };
    } else {
      // exclude → neutral
      return { excludeTags: state.excludeTags.filter(t => t !== clean) };
    }
  }),

  clearTagFilter: () => set({ includeTags: [], excludeTags: [] }),

  // Helper function
  createNodesMap: (nodesArray: MindNode[]) => {
    const nodesMap = new Map<string, MindNode>();
    nodesArray.forEach(node => nodesMap.set(node.id, node));
    return nodesMap;
  },

  // Data loading
  loadNodes: (nodesArray, synapses = []) => set((state) => ({
    nodes: state.createNodesMap(nodesArray),
    synapses,
    selectedNodeIds: new Set(),
    pendingSave: false,
  })),
  loadAssets: (assets) => set({ assets }),

  // Node CRUD
  addNode: (content, x, y, type = 'text') => set((state) => {
    const newNode: MindNode = {
      id: crypto.randomUUID(),
      content,
      x, y, z: 0,
      tags: [],
      type,
      createdAt: new Date().toISOString(),
      selected: false
    };
    const newNodes = new Map(state.nodes);
    newNodes.set(newNode.id, newNode);
    // Auto-lägg till i aktiv session
    let newSessions = state.sessions;
    if (state.activeSessionId) {
      newSessions = state.sessions.map(s =>
        s.id === state.activeSessionId
          ? { ...s, cardIds: [...s.cardIds, newNode.id] }
          : s
      );
    }
    return { nodes: newNodes, sessions: newSessions, pendingSave: true };
  }),

  addNodeWithId: (id, content, x, y, type = 'text') => set((state) => {
    const newNode: MindNode = {
      id,
      content,
      x, y, z: 0,
      tags: [],
      type,
      createdAt: new Date().toISOString(),
      selected: false
    };
    const newNodes = new Map(state.nodes);
    newNodes.set(newNode.id, newNode);
    // Auto-lägg till i aktiv session
    let newSessions = state.sessions;
    if (state.activeSessionId) {
      newSessions = state.sessions.map(s =>
        s.id === state.activeSessionId
          ? { ...s, cardIds: [...s.cardIds, id] }
          : s
      );
    }
    return { nodes: newNodes, sessions: newSessions, pendingSave: true };
  }),

  removeNode: (id) => set((state) => {
    const newNodes = new Map(state.nodes);
    newNodes.delete(id);
    const nextSelected = new Set(state.selectedNodeIds);
    nextSelected.delete(id);
    return {
      nodes: newNodes,
      synapses: state.synapses.filter(s => s.sourceId !== id && s.targetId !== id),
      selectedNodeIds: nextSelected,
      pendingSave: true
    };
  }),

  deleteNodesPermanently: (ids) => set((state) => {
    const newNodes = new Map(state.nodes);
    const idsSet = new Set(ids);

    // Remove from nodes map
    ids.forEach(id => newNodes.delete(id));

    // Remove from selection
    const nextSelected = new Set(state.selectedNodeIds);
    ids.forEach(id => nextSelected.delete(id));

    // Remove from all sessions
    const newSessions = state.sessions.map(session => ({
      ...session,
      cardIds: session.cardIds.filter(id => !idsSet.has(id))
    }));

    // Remove associated synapses
    const newSynapses = state.synapses.filter(s =>
      !idsSet.has(s.sourceId) && !idsSet.has(s.targetId)
    );

    return {
      nodes: newNodes,
      sessions: newSessions,
      synapses: newSynapses,
      selectedNodeIds: nextSelected,
      pendingSave: true
    };
  }),

  updateNode: (id, updates) => set((state) => {
    const existingNode = state.nodes.get(id);
    if (!existingNode) return {};
    const updatedNode: MindNode = {
      ...existingNode,
      ...updates,
      updatedAt: shouldTouchUpdatedAt(updates)
        ? new Date().toISOString()
        : existingNode.updatedAt,
    };
    const newNodes = new Map(state.nodes);
    newNodes.set(id, updatedNode);
    return { nodes: newNodes, pendingSave: true };
  }),
  updateNodesBulk: (updates) => set((state) => {
    if (!updates || updates.length === 0) return {};
    const newNodes = new Map(state.nodes);
    let changed = false;
    const now = new Date().toISOString();

    updates.forEach(({ id, updates: nodeUpdates }) => {
      const existingNode = newNodes.get(id);
      if (!existingNode) return;
      const updatedAt = nodeUpdates.updatedAt
        ?? (shouldTouchUpdatedAt(nodeUpdates) ? now : existingNode.updatedAt);
      newNodes.set(id, { ...existingNode, ...nodeUpdates, updatedAt });
      changed = true;
    });

    return changed ? { nodes: newNodes, pendingSave: true } : {};
  }),

  addSynapse: (sourceId, targetId, metadata) => set((state) => {
    const exists = state.synapses.find(s =>
      (s.sourceId === sourceId && s.targetId === targetId) ||
      (s.sourceId === targetId && s.targetId === sourceId)
    );
    if (exists) return {};
    return {
      synapses: [...state.synapses, {
        id: crypto.randomUUID(),
        sourceId,
        targetId,
        strength: 1,
        ...metadata
      }],
      pendingSave: true
    };
  }),

  updateNodePosition: (id, x, y) => set((state) => {
    const existingNode = state.nodes.get(id);
    if (!existingNode) return {};
    if (existingNode.pinned) return {};
    const updatedNode = { ...existingNode, x, y };
    const newNodes = new Map(state.nodes);
    newNodes.set(id, updatedNode);
    return { nodes: newNodes, pendingSave: true };
  }),

  updateNodePositions: (positions) => set((state) => {
    if (!positions || positions.size === 0) return {};

    let changed = false;
    const newNodes = new Map(state.nodes);

    positions.forEach((pos, id) => {
      const existingNode = newNodes.get(id);
      if (existingNode) {
        if (existingNode.pinned) return;
        const dx = Math.abs((existingNode.x || 0) - pos.x);
        const dy = Math.abs((existingNode.y || 0) - pos.y);

        // Use 0.5px threshold to allow arrangement functions to make subtle changes
        if (dx > 0.5 || dy > 0.5) {
          changed = true;
          newNodes.set(id, { ...existingNode, x: pos.x, y: pos.y });
        }
      }
    });

    if (!changed) return {};
    return { nodes: newNodes, pendingSave: true };
  }),

  setPendingSave: (pending) => set({ pendingSave: pending }),

  // AI processing state
  setNodeTagging: (nodeId, isTagging) => set((state) => {
    const newSet = new Set(state.taggingNodes);
    if (isTagging) {
      newSet.add(nodeId);
    } else {
      newSet.delete(nodeId);
    }
    return { taggingNodes: newSet };
  }),
  setNodeAIProcessing: (nodeId, provider) => set((state) => {
    const nextMap = new Map(state.aiProcessingNodes);
    if (provider) {
      nextMap.set(nodeId, provider);
    } else {
      nextMap.delete(nodeId);
    }
    return { aiProcessingNodes: nextMap };
  }),

  // Flip all image cards to text side (O+O)
  flipAllImageCardsToText: () => set((state) => {
    const newNodes = new Map(state.nodes);
    let changed = false;
    newNodes.forEach((node, id) => {
      if (node.type === 'image' && !node.isFlipped) {
        newNodes.set(id, { ...node, isFlipped: true });
        changed = true;
      }
    });
    return changed ? { nodes: newNodes, pendingSave: true } : {};
  }),

  // Flip all image cards to image side (O)
  flipAllImageCardsToImage: () => set((state) => {
    const newNodes = new Map(state.nodes);
    let changed = false;
    newNodes.forEach((node, id) => {
      if (node.type === 'image' && node.isFlipped) {
        newNodes.set(id, { ...node, isFlipped: false });
        changed = true;
      }
    });
    return changed ? { nodes: newNodes, pendingSave: true } : {};
  }),

  // Sequence actions (D+klick kedjor)
  startSequence: (nodeId) => set(() => ({
    activeSequence: {
      id: crypto.randomUUID(),
      nodeIds: [nodeId],
      createdAt: new Date().toISOString(),
    }
  })),

  addToSequence: (nodeId) => set((state) => {
    if (!state.activeSequence) return {};
    // Ignorera om kortet redan finns i kedjan
    if (state.activeSequence.nodeIds.includes(nodeId)) return {};
    return {
      activeSequence: {
        ...state.activeSequence,
        nodeIds: [...state.activeSequence.nodeIds, nodeId],
      }
    };
  }),

  finishSequence: () => set((state) => {
    if (!state.activeSequence) return {};
    // Spara bara om det finns minst 2 kort
    if (state.activeSequence.nodeIds.length < 2) {
      return { activeSequence: null };
    }
    return {
      sequences: [...state.sequences, state.activeSequence],
      activeSequence: null,
    };
  }),

  cancelSequence: () => set(() => ({
    activeSequence: null,
  })),

  removeFromSequence: (nodeId) => set((state) => {
    // Hitta sekvensen som innehåller nodeId
    const sequenceIndex = state.sequences.findIndex(s => s.nodeIds.includes(nodeId));
    if (sequenceIndex === -1) return {};

    const sequence = state.sequences[sequenceIndex];
    const newNodeIds = sequence.nodeIds.filter(id => id !== nodeId);

    // Om färre än 2 kort kvar, ta bort hela sekvensen
    if (newNodeIds.length < 2) {
      return {
        sequences: state.sequences.filter((_, i) => i !== sequenceIndex),
      };
    }

    // Annars uppdatera sekvensen (sys ihop)
    const updatedSequence = { ...sequence, nodeIds: newNodeIds };
    const newSequences = [...state.sequences];
    newSequences[sequenceIndex] = updatedSequence;
    return { sequences: newSequences };
  }),

  // Conversation actions (AI-chattar med minne)
  loadConversations: (conversations) => set({ conversations }),

  createConversation: (provider, contextNodeIds = []) => {
    const id = crypto.randomUUID();
    const now = new Date().toISOString();
    const newConversation: Conversation = {
      id,
      title: 'Nytt samtal',
      createdAt: now,
      updatedAt: now,
      messages: [],
      contextNodeIds,
      provider,
    };
    useBrainStore.setState((state: BrainStore) => ({
      conversations: [newConversation, ...state.conversations],
      activeConversationId: id,
    }));
    return id;
  },

  setActiveConversation: (id) => set({ activeConversationId: id }),

  addMessageToConversation: (conversationId, message) => set((state) => {
    const convIndex = state.conversations.findIndex(c => c.id === conversationId);
    if (convIndex === -1) return {};

    const conv = state.conversations[convIndex];
    const newMessage: ConversationMessage = {
      ...message,
      timestamp: new Date().toISOString(),
    };

    const updatedConv: Conversation = {
      ...conv,
      messages: [...conv.messages, newMessage],
      updatedAt: new Date().toISOString(),
      // Lägg till nya kort till kontexten om de finns
      contextNodeIds: message.addedNodeIds
        ? [...new Set([...conv.contextNodeIds, ...message.addedNodeIds])]
        : conv.contextNodeIds,
    };

    const newConversations = [...state.conversations];
    newConversations[convIndex] = updatedConv;
    return { conversations: newConversations };
  }),

  updateConversation: (id, updates) => set((state) => {
    const convIndex = state.conversations.findIndex(c => c.id === id);
    if (convIndex === -1) return {};

    const updatedConv: Conversation = {
      ...state.conversations[convIndex],
      ...updates,
      updatedAt: new Date().toISOString(),
    };

    const newConversations = [...state.conversations];
    newConversations[convIndex] = updatedConv;
    return { conversations: newConversations };
  }),

  archiveConversation: (id) => set((state) => {
    const convIndex = state.conversations.findIndex(c => c.id === id);
    if (convIndex === -1) return {};

    const updatedConv: Conversation = {
      ...state.conversations[convIndex],
      isArchived: true,
      updatedAt: new Date().toISOString(),
    };

    const newConversations = [...state.conversations];
    newConversations[convIndex] = updatedConv;
    return { conversations: newConversations };
  }),

  // Session actions
  loadSessions: (sessions) => set({ sessions }),

  createSession: (name) => {
    const id = crypto.randomUUID();
    const now = Date.now();
    const newSession: Session = {
      id,
      name,
      cardIds: [],
      viewState: { x: 0, y: 0, zoom: 1 },
      createdAt: now,
      lastOpened: now,
    };
    useBrainStore.setState((state: BrainStore) => ({
      sessions: [...state.sessions, newSession],
      activeSessionId: id,
    }));
    return id;
  },

  deleteSession: (id) => set((state) => ({
    sessions: state.sessions.filter(s => s.id !== id),
    activeSessionId: state.activeSessionId === id ? null : state.activeSessionId,
  })),

  renameSession: (id, name) => set((state) => ({
    sessions: state.sessions.map(s => s.id === id ? { ...s, name } : s),
  })),

  switchSession: (id) => set((state) => {
    // Spara nuvarande vy-state innan byte (om vi har en aktiv session)
    const currentSession = state.sessions.find(s => s.id === state.activeSessionId);
    if (currentSession) {
      // View state sparas separat via saveSessionViewState
    }
    return {
      activeSessionId: id,
      sessions: state.sessions.map(s =>
        s.id === id ? { ...s, lastOpened: Date.now() } : s
      ),
    };
  }),

  addCardsToSession: (sessionId, cardIds) => set((state) => ({
    sessions: state.sessions.map(s => {
      if (s.id !== sessionId) return s;
      const newCardIds = [...new Set([...s.cardIds, ...cardIds])];
      return { ...s, cardIds: newCardIds };
    }),
  })),

  removeCardsFromSession: (sessionId, cardIds) => set((state) => ({
    sessions: state.sessions.map(s => {
      if (s.id !== sessionId) return s;
      const cardIdSet = new Set(cardIds);
      return { ...s, cardIds: s.cardIds.filter(id => !cardIdSet.has(id)) };
    }),
  })),

  saveSessionViewState: (sessionId, viewState) => set((state) => ({
    sessions: state.sessions.map(s =>
      s.id === sessionId ? { ...s, viewState } : s
    ),
  })),

  // View mode actions
  setViewMode: (mode) => set((state) => ({
    viewMode: mode,
    canvasWeekView: mode === 'canvas' ? state.canvasWeekView : false,
    canvasEternalView: mode === 'canvas' ? state.canvasEternalView : false,
  })),
  toggleViewMode: () => set((state) => ({
    viewMode: state.viewMode === 'canvas' ? 'column' : 'canvas',
    canvasWeekView: state.viewMode === 'canvas' ? false : state.canvasWeekView,
    canvasEternalView: state.viewMode === 'canvas' ? false : state.canvasEternalView,
  })),
  setColumnSort: (sort) => set({ columnSort: sort }),
  setColumnCount: (count) => set({ columnCount: Math.max(1, Math.min(6, count)) }),
  setColumnShowOnlySelected: (enabled) => set({ columnShowOnlySelected: enabled }),
  setCanvasWeekView: (enabled) => set({ canvasWeekView: enabled }),
  setCanvasEternalView: (enabled) => set({ canvasEternalView: enabled }),
  toggleColumnShowComments: () => set((state) => ({ columnShowComments: !state.columnShowComments })),
  toggleColumnShowTags: () => set((state) => ({ columnShowTags: !state.columnShowTags })),
  toggleColumnShowMeta: () => set((state) => ({ columnShowMeta: !state.columnShowMeta })),
  toggleColumnShowCaptions: () => set((state) => ({ columnShowCaptions: !state.columnShowCaptions })),

  // Migration: Move links from comment to link field
  migrateLinksFromCommentToLink: () => {
    let migratedCount = 0;

    set((state) => {
      const updatedNodes = new Map(state.nodes);

      updatedNodes.forEach((node, id) => {
        // Skip if link field already has content
        if (node.link) return;

        // Check if comment contains a markdown link
        if (node.comment) {
          const linkMatch = node.comment.match(/\[([^\]]+)\]\(([^)]+)\)/);
          if (linkMatch) {
            const linkText = linkMatch[0];
            const linkName = linkMatch[1];
            const linkUrl = linkMatch[2];

            // Move link to link field and remove from comment
            const updatedComment = node.comment.replace(linkText, '').trim();

            updatedNodes.set(id, {
              ...node,
              link: `[${linkName}](${linkUrl})`,
              comment: updatedComment || undefined
            });

            migratedCount++;
          }
        }
      });

      return { nodes: updatedNodes };
    });

    console.log(`✅ Migrated ${migratedCount} cards from comment to link field`);
    return migratedCount;
  },

  // Selection slice
  ...createSelectionSlice(set),

  // History slice
  ...createHistorySlice(set),

  // Trail slice
  ...createTrailSlice(set, get),

  // Notification slice
  ...createNotificationSlice(set, get, api),
}));

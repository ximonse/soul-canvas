// src/hooks/useIntelligence.ts
import { useState, useCallback } from 'react';
import { useBrainStore } from '../store/useBrainStore';
import {
  generateNodeEmbedding,
  findSimilarNodes,
  batchGenerateEmbeddings,
  generateEmbedding,
  findNodesSimilarToGroup,
} from '../utils/embeddings';
import { calculateConnectedNodesLayout } from '../utils/forceLayout';
import { 
  generateReflection, 
  generateSemanticTags, 
  analyzeCluster, 
  generateNodeSummaryComment, 
  generateNodeTitle 
} from '../utils/claude';
import { GRAVITY } from '../utils/constants';
import type { MindNode, AIReflection } from '../types/types';

export const useIntelligence = () => {
  const store = useBrainStore();
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState({ current: 0, total: 0 });
  const [lastReflection, setLastReflection] = useState<AIReflection | null>(null);

  /**
   * Generate embedding for a single node
   */
  const embedNode = useCallback(async (nodeId: string): Promise<boolean> => {
    const node = store.nodes.get(nodeId);
    if (!node || !store.openaiKey) return false;

    try {
      setIsProcessing(true);
      const embedding = await generateNodeEmbedding(node, store.openaiKey);
      
      store.updateNode(nodeId, {
        embedding,
        lastEmbedded: new Date().toISOString(),
      });
      
      return true;
    } catch (error) {
      console.error('Embedding error:', error);
      return false;
    } finally {
      setIsProcessing(false);
    }
  }, [store]);

  /**
   * Generate embeddings for all nodes that don't have them
   */
  const embedAllNodes = useCallback(async (): Promise<number> => {
    if (!store.openaiKey) return 0;

    const nodesToEmbed = Array.from(store.nodes.values()).filter(n => !n.embedding);
    if (nodesToEmbed.length === 0) return 0;

    try {
      setIsProcessing(true);
      setProgress({ current: 0, total: nodesToEmbed.length });

      const embeddings = await batchGenerateEmbeddings(
        nodesToEmbed,
        store.openaiKey,
        (current, total) => setProgress({ current, total })
      );

      // Update all nodes with their embeddings
      embeddings.forEach((embedding, nodeId) => {
        store.updateNode(nodeId, {
          embedding,
          lastEmbedded: new Date().toISOString(),
        });
      });

      return embeddings.size;
    } catch (error) {
      console.error('Batch embedding error:', error);
      return 0;
    } finally {
      setIsProcessing(false);
      setProgress({ current: 0, total: 0 });
    }
  }, [store]);

  /**
   * Find and create links between semantically similar nodes
   */
  const autoLinkSimilarNodes = useCallback(async (nodeId?: string): Promise<number> => {
    // Use fresh state to avoid stale closures
    const currentState = useBrainStore.getState();
    if (!currentState.enableAutoLink) return 0;

    // Prevent concurrent execution
    if (isProcessing) return 0;

    const threshold = currentState.autoLinkThreshold || 0.75;
    const allNodes = Array.from(currentState.nodes.values());
    const nodesToCheck = nodeId
      ? [currentState.nodes.get(nodeId)].filter(Boolean) as MindNode[]
      : allNodes.filter(n => n.embedding);

    let linksCreated = 0;

    setIsProcessing(true);
    try {
      for (const node of nodesToCheck) {
        if (!node.embedding) continue;

        const similarNodes = findSimilarNodes(node, allNodes, threshold);

        for (const { nodeId: targetId, similarity } of similarNodes) {
          // Get fresh synapses state to check for existing links
          const freshState = useBrainStore.getState();
          const linkExists = freshState.synapses.some(
            s => (s.sourceId === node.id && s.targetId === targetId) ||
                 (s.sourceId === targetId && s.targetId === node.id)
          );

          if (!linkExists) {
            // Pass metadata directly to addSynapse - no race condition
            freshState.addSynapse(node.id, targetId, {
              autoGenerated: true,
              similarity
            });
            linksCreated++;
          }
        }
      }
    } finally {
      setIsProcessing(false);
    }

    return linksCreated;
  }, [isProcessing]);

  /**
   * Generate both practical and hidden tags for a node using Claude
   * Practical tags merge with existing tags, hidden tags replace semanticTags
   */
  const generateTags = useCallback(async (nodeId: string): Promise<{ practical: string[]; hidden: string[] }> => {
    const node = store.nodes.get(nodeId);
    if (!node || !store.claudeKey) return { practical: [], hidden: [] };

    try {
      setIsProcessing(true);
      store.setNodeTagging(nodeId, true);  // Start tagging animation
      const result = await generateSemanticTags(node, store.claudeKey);

      // Merge practical tags with existing tags (avoid duplicates)
      const existingTags = node.tags || [];
      const newPracticalTags = result.practicalTags.filter(
        tag => !existingTags.some(existing => existing.toLowerCase() === tag.toLowerCase())
      );
      const mergedTags = [...existingTags, ...newPracticalTags];

      store.updateNode(nodeId, {
        tags: mergedTags,
        semanticTags: result.hiddenTags,
      });

      return { practical: result.practicalTags, hidden: result.hiddenTags };
    } catch (error) {
      console.error('Tag generation error:', error);
      return { practical: [], hidden: [] };
    } finally {
      store.setNodeTagging(nodeId, false);  // Stop tagging animation
      setIsProcessing(false);
    }
  }, [store]);

  /**
   * Generate a short summary and write to node.comment
   */
  const summarizeToComment = useCallback(async (nodeId?: string): Promise<number> => {
    const currentState = useBrainStore.getState();
    const key = currentState.claudeKey;
    if (!key) return 0;

    const selected = Array.from(currentState.nodes.values()).filter(n => n.selected);
    const targets = nodeId
      ? [currentState.nodes.get(nodeId)].filter(Boolean) as MindNode[]
      : (selected.length > 0 ? selected : []);
    if (targets.length === 0) return 0;

    currentState.saveStateForUndo?.();
    let updated = 0;
    setIsProcessing(true);
    try {
      for (const node of targets) {
        const summary = await generateNodeSummaryComment(node, key);
        if (summary) {
          currentState.updateNode(node.id, { comment: summary });
          updated++;
        }
      }
      return updated;
    } finally {
      setIsProcessing(false);
    }
  }, []);

  /**
   * Generate a concise title for nodes
   */
  const suggestTitle = useCallback(async (nodeId?: string): Promise<number> => {
    const currentState = useBrainStore.getState();
    const key = currentState.claudeKey;
    if (!key) return 0;

    const selected = Array.from(currentState.nodes.values()).filter(n => n.selected);
    const targets = nodeId
      ? [currentState.nodes.get(nodeId)].filter(Boolean) as MindNode[]
      : (selected.length > 0 ? selected : []);
    if (targets.length === 0) return 0;

    currentState.saveStateForUndo?.();
    let updated = 0;
    setIsProcessing(true);
    try {
      for (const node of targets) {
        const title = await generateNodeTitle(node, key);
        if (title) {
          currentState.updateNode(node.id, { title });
          updated++;
        }
      }
      return updated;
    } finally {
      setIsProcessing(false);
    }
  }, []);

  /**
   * Generate a reflective question based on selected or all nodes
   */
  const reflect = useCallback(async (): Promise<AIReflection | null> => {
    if (!store.claudeKey) return null;

    const selectedNodes = Array.from(store.nodes.values()).filter(n => n.selected);
    const nodesToAnalyze = selectedNodes.length > 0 ? selectedNodes : Array.from(store.nodes.values());

    if (nodesToAnalyze.length === 0) return null;

    try {
      setIsProcessing(true);
      const reflection = await generateReflection(nodesToAnalyze, store.claudeKey);
      setLastReflection(reflection);
      return reflection;
    } catch (error) {
      console.error('Reflection error:', error);
      return null;
    } finally {
      setIsProcessing(false);
    }
  }, [store]);

  /**
   * Analyze a cluster of connected nodes
   */
  const analyzeSelectedCluster = useCallback(async (): Promise<string | null> => {
    if (!store.claudeKey) return null;

    const selectedNodes = Array.from(store.nodes.values()).filter(n => n.selected);
    if (selectedNodes.length < 2) return null;

    try {
      setIsProcessing(true);
      const insight = await analyzeCluster(selectedNodes, store.claudeKey);
      return insight;
    } catch (error) {
      console.error('Cluster analysis error:', error);
      return null;
    } finally {
      setIsProcessing(false);
    }
  }, [store]);

  /**
   * Search nodes by semantic similarity to a query
   */
  const semanticSearch = useCallback(async (query: string): Promise<MindNode[]> => {
    if (!store.openaiKey) return [];

    if (!query.trim()) return [];

    try {
      setIsProcessing(true);
      
      // Generate embedding for the search query
      const queryEmbedding = await generateEmbedding(query, store.openaiKey);

      // Create a dummy MindNode for the query
      const queryMindNode: MindNode = {
        id: 'search-query',
        content: query,
        x: 0, y: 0, z: 0,
        tags: [],
        createdAt: new Date().toISOString(),
        type: 'text',
        embedding: queryEmbedding,
      };

      // Find similar nodes
      const nodesWithEmbeddings = Array.from(store.nodes.values()).filter(n => n.embedding);
      
      const results = findSimilarNodes(queryMindNode, nodesWithEmbeddings, 0); // Find similar nodes

      return results
        .filter(r => r.similarity > 0.5) // Threshold for search
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, 10) // Top 10 results
        .map(r => store.nodes.get(r.nodeId)!); // Map back to MindNode objects

    } catch (error) {
      console.error('Semantic search error:', error);
      return [];
    } finally {
      setIsProcessing(false);
    }
  }, [store]);

  /**
   * Attract similar nodes to the selected nodes
   * Moves similar nodes closer to form a cluster
   */
  const attractSimilarNodes = useCallback((): number => {
    const currentState = useBrainStore.getState();
    const allNodes = Array.from(currentState.nodes.values());
    const selectedNodes = allNodes.filter(n => n.selected);

    if (selectedNodes.length === 0) return 0;

    // Hitta liknande noder
    const threshold = currentState.autoLinkThreshold || 0.6;
    const similarResults = findNodesSimilarToGroup(selectedNodes, allNodes, threshold);

    if (similarResults.length === 0) return 0;

    // Beräkna centroid av markerade kort
    const centerX = selectedNodes.reduce((sum, n) => sum + n.x, 0) / selectedNodes.length;
    const centerY = selectedNodes.reduce((sum, n) => sum + n.y, 0) / selectedNodes.length;

    // Flytta liknande kort i en cirkel runt centroiden
    const positions = new Map<string, { x: number; y: number }>();
    const radius = 250; // Bas-radie
    const angleStep = (2 * Math.PI) / Math.max(similarResults.length, 1);

    similarResults.forEach((result, index) => {
      const node = currentState.nodes.get(result.nodeId);
      if (!node || node.pinned) return; // Hoppa över pinnade kort

      const angle = angleStep * index - Math.PI / 2; // Starta från toppen
      const distance = radius + (1 - result.similarity) * 200; // Mer lika = närmare

      positions.set(result.nodeId, {
        x: centerX + Math.cos(angle) * distance,
        y: centerY + Math.sin(angle) * distance,
      });
    });

    // Uppdatera positioner
    if (positions.size > 0) {
      currentState.updateNodePositions(positions);
    }

    return positions.size;
  }, []);

  /**
   * Arrange nodes as a force-directed graph based on their connections
   */
  const arrangeAsGraph = useCallback((centerX?: number, centerY?: number, gravity?: number): number => {
    const currentState = useBrainStore.getState();
    const allNodes = Array.from(currentState.nodes.values());

    if (currentState.synapses.length === 0) return 0;

    // Beräkna center om inte angivet
    const cx = centerX ?? allNodes.reduce((sum, n) => sum + n.x, 0) / allNodes.length;
    const cy = centerY ?? allNodes.reduce((sum, n) => sum + n.y, 0) / allNodes.length;

    // Använd angiven gravity eller från store
    const g = Math.max(GRAVITY.MIN, Math.min(GRAVITY.MAX, gravity ?? currentState.graphGravity));

    const visibleSynapses = currentState.synapses.filter(
      s => (s.similarity || 1) >= currentState.synapseVisibilityThreshold
    );
    if (visibleSynapses.length === 0) return 0;

    const positions = calculateConnectedNodesLayout(
      allNodes,
      visibleSynapses,
      { centerX: cx, centerY: cy, iterations: 300, gravity: g }
    );

    if (positions.size > 0) {
      currentState.updateNodePositions(positions);
    }

    return positions.size;
  }, []);

  return {
    // State
    isProcessing,
    progress,
    lastReflection,

    // Actions
    embedNode,
    embedAllNodes,
    autoLinkSimilarNodes,
    generateTags,
    summarizeToComment,
    suggestTitle,
    reflect,
    analyzeSelectedCluster,
    semanticSearch,
    attractSimilarNodes,
    arrangeAsGraph,
  };
};
